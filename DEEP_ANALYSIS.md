# Глубокий концептуальный анализ проблем

## ПРОБЛЕМА 1: Изменения не сохраняются (только комментарии и массовые замены)

### Анализ потока выполнения:

#### Массовые замены (РАБОТАЮТ):
```
if replace_all or is_global_change:
    doc = Document(filename)  # Создается ОДИН объект
    # ... делаем замены в doc ...
    doc.save(filename)  # Сохраняем ОДИН РАЗ после всех замен
    return {"success": True, ...}
```
✅ **Работает**, потому что:
- Создается один объект `Document()`
- Все изменения применяются к этому объекту
- Файл сохраняется ОДИН РАЗ в конце
- Функция возвращает успех и НЕ продолжает выполнение

#### Комментарии (РАБОТАЮТ):
```
await mcp_client.add_comment(...)
# MCP сервер сохраняет файл автоматически
return {"success": True, ...}
```
✅ **Работают**, потому что:
- Используется MCP сервер, который сохраняет файл на своей стороне
- Функция возвращает успех сразу

#### Обычные замены (НЕ РАБОТАЮТ):

**ШАГ 1**: Локальная замена вызывается ПЕРВОЙ
```
local_replaced_first = mcp_client._replace_text_locally_with_tables(...)
if local_replaced_first:
    verify_doc_local = Document(filename)  # Читаем файл СНОВА
    # Проверяем результат
    if new_text in verify_para_text_local:
        replaced = True  # ✅ Устанавливаем флаг
    else:
        # ⚠️ НЕ устанавливаем replaced = True!
        logger.warning("текст не найден")
```

**ПРОБЛЕМА**: Если локальная замена вернула `True`, но верификация показала, что текст не найден, мы НЕ устанавливаем `replaced = True`. Но файл уже может быть изменен локальной заменой! Или наоборот - локальная замена НЕ сохранила файл, но вернула `True`.

**ШАГ 2**: Если `replaced = False`, создаем `Document()` и пробуем другие методы
```
if not replaced:
    doc = Document(filename)  # Читаем файл СНОВА
    para = doc.paragraphs[paragraph_index]
    # ... пробуем разные методы замены ...
```

**ШАГ 3**: В конце функции
```
if not replaced:
    return {"success": False, ...}  # Возвращаем ошибку

# КРИТИЧЕСКОЕ: Сохраняем только если doc был создан
if doc is not None:
    doc.save(filename)  # Сохраняем, НО doc может содержать СТАРУЮ версию!
```

### КОРНЕВАЯ ПРИЧИНА:

1. **Локальная замена может вернуть `True`, но НЕ сохранить файл**
   - В `_replace_text_locally_with_tables` сохранение происходит только если `replacements_made > 0`
   - Но метод может вернуть `True` по другим причинам (или из-за ошибки)

2. **Локальная замена может сохранить файл, но верификация не найдет изменения**
   - Проблемы с кодировкой, пробелами, регистром
   - Изменения в таблицах, а мы проверяем только параграфы

3. **Если `replaced = False`, мы создаем НОВЫЙ `Document(filename)`, который читает файл с диска**
   - Если локальная замена НЕ сохранила файл, мы читаем СТАРУЮ версию
   - Если локальная замена сохранила файл, мы читаем НОВУЮ версию, но текст может быть не найден из-за проблем с проверкой

4. **В конце функции `doc.save(filename)` вызывается ТОЛЬКО если `doc is not None`**
   - Если локальная замена сработала, `doc = None`, и сохранение не происходит
   - Но если локальная замена НЕ сохранила файл (хотя вернула `True`), изменения теряются!

### РЕШЕНИЕ:

1. **Гарантировать, что локальная замена ВСЕГДА сохраняет файл, если вернула `True`**
   - Проверить логику `_replace_text_locally_with_tables`
   - Убедиться, что `doc.save(filename)` вызывается ПЕРЕД `return True`

2. **Улучшить верификацию результата локальной замены**
   - Проверять не только текст параграфа, но и таблицы
   - Учитывать возможные различия в форматировании

3. **Убрать двойное чтение файла**
   - Если локальная замена вернула `True`, НЕ создавать новый `Document()` для проверки
   - Использовать результат верификации локальной замены напрямую

4. **Финальное сохранение ВСЕГДА**
   - Даже если локальная замена сработала, убедиться, что файл сохранен
   - Или убрать финальное сохранение, если локальная замена гарантированно сохраняет

## ПРОБЛЕМА 2: Только одна инструкция распознается в блоке "проверка инструкции"

### Анализ:

**Проверка инструкций** использует `_parse_instructions_with_llm`:
- `temperature=0`
- `max_tokens=16384`
- `response_format={"type": "json_object"}`

**Применение инструкций** использует `_simple_parse_changes_with_llm`:
- `temperature=0.1`
- `max_tokens=4000`
- `response_format` не указан (по умолчанию text)

### КРИТИЧЕСКАЯ РАЗНИЦА:

1. **`response_format={"type": "json_object"}`** в проверке инструкций может заставить LLM вернуть только один объект, а не массив!

2. **`max_tokens=4000`** для применения инструкций может быть недостаточно для множественных инструкций

3. **Разные промпты**: Нужно проверить, что промпты для проверки инструкций явно требуют массив

### РЕШЕНИЕ:

1. **Убрать `response_format={"type": "json_object"}`** или изменить на `response_format=None`
2. **Увеличить `max_tokens`** для проверки инструкций
3. **Убедиться, что промпты явно требуют массив `{"changes": [...]}`**

