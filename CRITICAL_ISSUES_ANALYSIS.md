# Критический анализ проблем с сохранением изменений

## ПРОБЛЕМА 1: Изменения логируются как успешные, но не фиксируются в файле

### Корневая причина:

**Каждое изменение создает новый объект `Document(filename)` в памяти, но изменения не сохраняются в файл перед следующим изменением!**

### Детальный анализ потока выполнения:

1. **Массовая замена работает** (строка 4437-4468):
   ```
   if replace_all or is_global_change:
       doc = Document(filename)  # НОВЫЙ объект
       # ... делаем замены ...
       doc.save(filename)  # СОХРАНЯЕМ после всех замен
   ```
   ✅ **Работает**, потому что создается один объект, все изменения применяются, и файл сохраняется ОДИН РАЗ в конце

2. **Локальная замена НЕ работает** для отдельных изменений:
   ```
   _handle_replace_text():
       doc = Document(filename)  # Строка 4563 - НОВЫЙ объект для каждого изменения
       para = doc.paragraphs[paragraph_index]  # Работаем с этим объектом
       # ... делаем замены в памяти ...
       
       # Пробуем локальную замену (строка 4735):
       local_replaced = mcp_client._replace_text_locally_with_tables(
           filename, target_text, new_text, paragraph_index
       )
       # Внутри локальной замены:
       # doc = Document(filename)  # Строка 564 - ЕЩЕ ОДИН НОВЫЙ объект!
       # ... делаем замены ...
       # doc.save(filename)  # Строка 652 - СОХРАНЯЕМ
       
       # Но затем, если локальная замена не сработала, пробуем MCP:
       # MCP может не сохранить файл!
       
       # В конце _handle_replace_text (строка 4980):
       # doc.save(filename)  # Сохраняем НО doc был создан на строке 4563!
       # Если между строкой 4563 и 4980 были вызовы локальной замены или MCP,
       # то doc на строке 4980 содержит СТАРУЮ версию документа!
   ```

3. **Критическая проблема**:
   - На строке 4563 создается `doc = Document(filename)` - это читает файл с диска
   - Затем вызывается локальная замена, которая создает СВОЙ `Document(filename)` и сохраняет
   - Но если локальная замена не сработала и мы пробуем MCP, MCP может не сохранить
   - Затем на строке 4980 мы вызываем `doc.save(filename)`, но `doc` все еще содержит старую версию из строки 4563!
   - **Результат**: Файл перезаписывается старой версией!

4. **Почему массовая замена работает**:
   - Создается один объект `Document(filename)` на строке 4439
   - Все изменения применяются к этому объекту
   - Файл сохраняется ОДИН РАЗ на строке 4468 после всех изменений
   - Между созданием объекта и сохранением нет промежуточных операций с другими объектами

5. **Почему комментарии работают**:
   - Комментарии используют MCP `add_comment`, который сохраняет файл на стороне MCP сервера
   - Это отдельный механизм, который работает независимо

### Решение:

1. **Убрать создание `Document()` на строке 4563** - оно не нужно, если мы используем локальную замену
2. **Убрать `doc.save(filename)` на строке 4980** - файл уже сохранен локальной заменой или MCP
3. **Проверять, что файл действительно сохранен** после каждого изменения

## ПРОБЛЕМА 2: Проверка инструкций находит только одну инструкцию

### Корневая причина:

**LLM получает весь текст инструкций, но останавливается на первой найденной инструкции и не читает дальше.**

### Детальный анализ:

1. **Текст передается полностью**:
   - `changes_text` передается полностью в `_simple_parse_changes_with_llm`
   - LLM получает весь текст в промпте

2. **Проблема в промптах**:
   - Промпты содержат инструкции "прочитай весь документ", но LLM их не следует
   - Нет явного требования подсчитать количество инструкций ПЕРЕД генерацией JSON
   - Нет примера с множественными инструкциями в начале промпта

3. **Проблема в логике восстановления JSON**:
   - `_extract_json_from_response` правильно обрабатывает один объект
   - Но это не решает проблему - LLM все равно возвращает только один объект

### Решение:

1. **Изменить структуру промптов**:
   - Добавить в начало промпта явную инструкцию: "ПОДСЧИТАЙ количество инструкций ПЕРЕД генерацией JSON"
   - Добавить пример с множественными инструкциями в самом начале
   - Сделать промпт более структурированным с явными шагами

2. **Увеличить max_tokens**:
   - Если LLM останавливается раньше, возможно, не хватает токенов для генерации множественных инструкций
   - Текущее значение: `max_tokens=4000` для простого парсинга, `max_tokens=16384` для проверки инструкций

3. **Использовать более явные инструкции**:
   - Вместо "прочитай весь документ" использовать "ПОСЧИТАЙ количество абзацев с инструкциями"
   - Требовать явный подсчет перед генерацией JSON

## КРИТИЧЕСКИЕ ИЗМЕНЕНИЯ НЕОБХОДИМЫ:

1. **Убрать создание `Document()` в начале `_handle_replace_text`** (строка 4563)
2. **Убрать `doc.save(filename)` в конце `_handle_replace_text`** (строка 4980)
3. **Проверять, что файл сохранен после локальной замены**
4. **Усилить промпты с явным подсчетом инструкций**

